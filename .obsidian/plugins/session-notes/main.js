/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SNote
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var SNote = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.sessionNotes = [];
  }
  async onload() {
    this.addCommand({
      id: "open-temp-note",
      name: "Open a temporary note (delete on change)",
      callback: () => this.openTempNote()
    });
    this.addCommand({
      id: "open-session-note",
      name: "Open a session note (delete on app close)",
      callback: () => this.openSessionNote()
    });
    window.addEventListener("beforeunload", (event) => {
      if (this.sessionNotes.length === 0) {
        return;
      }
      event.preventDefault();
      this.deleteSessionNotes();
    });
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.checkTempNoteDeletion();
    }));
  }
  async openTempNote() {
    const file = await this.app.vault.create("Temp Note.md", "");
    this.tempNote = file;
    const leaf = this.app.workspace.getLeaf();
    leaf.openFile(file);
  }
  async openSessionNote() {
    let count = 1;
    let baseName = "Session Note";
    let newFileName = `${baseName} ${count}.md`;
    while (this.app.vault.getAbstractFileByPath(newFileName)) {
      count++;
      newFileName = `${baseName} ${count}.md`;
    }
    const file = await this.app.vault.create(newFileName, "");
    this.sessionNotes.push(file);
    const leaf = this.app.workspace.getLeaf();
    leaf.openFile(file);
  }
  checkTempNoteDeletion() {
    const activeFile = this.app.workspace.getActiveFile();
    if (this.tempNote && (!activeFile || activeFile.path !== this.tempNote.path)) {
      this.app.vault.delete(this.tempNote);
      this.tempNote = void 0;
    }
  }
  async deleteSessionNotes() {
    const deletionPromises = this.sessionNotes.map(async (note) => {
      try {
        await this.app.vault.delete(note);
      } catch (error) {
        console.error(`Failed to delete session note: ${note.path}`, error);
      }
    });
    await Promise.allSettled(deletionPromises);
    this.sessionNotes = [];
    window.close();
  }
  onunload() {
    window.removeEventListener("beforeunload", () => this.deleteSessionNotes());
  }
};


/* nosourcemap */